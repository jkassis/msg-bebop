//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           3.2.0
//
//
//       bebopc source:
//           https://github.com/6over3/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
#pragma once
#include <cstddef>
#include <cstdint>
#include <map>
#include <memory>
#include <optional>
#include <string>
#include <variant>
#include <vector>
#include "bebop.hpp"

struct Msg {
  static const size_t minimalEncodedSize = 20;
  std::string body;
  std::string fromId;
  std::string id;
  std::vector<std::string> toIds;
  std::string type;

  static size_t encodeInto(const Msg& message, std::vector<uint8_t>& targetBuffer) {
    ::bebop::Writer writer{targetBuffer};
    return Msg::encodeInto(message, writer);
  }

  template<typename T = ::bebop::Writer> static size_t encodeInto(const Msg& message, T& writer) {
    size_t before = writer.length();
    writer.writeString(message.body);
    writer.writeString(message.fromId);
    writer.writeString(message.id);
    {
      const auto length0 = message.toIds.size();
      writer.writeUint32(length0);
      for (const auto& i0 : message.toIds) {
        writer.writeString(i0);
      }
    }
    writer.writeString(message.type);    size_t after = writer.length();
    return after - before;
  }

  size_t encodeInto(std::vector<uint8_t>& targetBuffer) { return Msg::encodeInto(*this, targetBuffer); }
  size_t encodeInto(::bebop::Writer& writer) { return Msg::encodeInto(*this, writer); }

  static Msg decode(const uint8_t* sourceBuffer, size_t sourceBufferSize) {
    Msg result;
    Msg::decodeInto(sourceBuffer, sourceBufferSize, result);
    return result;
  }

  static Msg decode(const std::vector<uint8_t>& sourceBuffer) {
    return Msg::decode(sourceBuffer.data(), sourceBuffer.size());
  }

  static Msg decode(::bebop::Reader& reader) {
    Msg result;
    Msg::decodeInto(reader, result);
    return result;
  }

  static size_t decodeInto(const uint8_t* sourceBuffer, size_t sourceBufferSize, Msg& target) {
    ::bebop::Reader reader{sourceBuffer, sourceBufferSize};
    return Msg::decodeInto(reader, target);
  }

  static size_t decodeInto(const std::vector<uint8_t>& sourceBuffer, Msg& target) {
    return Msg::decodeInto(sourceBuffer.data(), sourceBuffer.size(), target);
  }

  static size_t decodeInto(::bebop::Reader& reader, Msg& target) {
    target.body = reader.readString();
    target.fromId = reader.readString();
    target.id = reader.readString();
    {
      const auto length0 = reader.readUint32();
      target.toIds = std::vector<std::string>();
      target.toIds.reserve(length0);
      for (size_t i0 = 0; i0 < length0; i0++) {
        std::string x0;
        x0 = reader.readString();
        target.toIds.push_back(x0);
      }
    }
    target.type = reader.readString();    return reader.bytesRead();
  }

  size_t byteCount() {
    ::bebop::ByteCounter counter{};
    Msg::encodeInto<::bebop::ByteCounter>(*this, counter);
    return counter.length();
  }
};

