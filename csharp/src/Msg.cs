//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           3.2.0
//
//
//       bebopc source:
//           https://github.com/6over3/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//
// This source code was auto-generated by bebopc, Version=3.2.0.
//
/// <summary>A static class which contains schema defined constants.</summary>
[global::System.CodeDom.Compiler.GeneratedCode("bebopc", "3.2.0")]
public static class BopConstants {
  public static readonly byte[] BEBOP_SCHEMA = new byte[] {
  3, 1, 0, 0, 0, 77, 115, 103, 0, 1, 0, 0, 20, 0, 0, 0, 0,
  5, 98, 111, 100, 121, 0, 245, 255, 255, 255, 0, 102, 114,
  111, 109, 73, 100, 0, 245, 255, 255, 255, 0, 105, 100, 0,
  245, 255, 255, 255, 0, 116, 111, 73, 100, 115, 0, 242,
  255, 255, 255, 0, 245, 255, 255, 255, 0, 116, 121, 112,
  101, 0, 245, 255, 255, 255, 0, 0, 0, 0, 0
  };
}

[global::System.CodeDom.Compiler.GeneratedCode("bebopc", "3.2.0")]
[global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Struct)]
public partial class Msg : global::Bebop.Runtime.BaseBebopRecord, global::Bebop.Runtime.IDecodable<Msg>, global::System.IEquatable<Msg> {
  /// <inheritdoc />
  public sealed override int MaxByteCount => GetMaxByteCount();
  /// <inheritdoc />
  public sealed override int ByteCount => GetByteCount();
  [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
  public string Body { get; init; }
  [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
  public string FromId { get; init; }
  [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
  public string ID { get; init; }
  [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
  public string[] ToIds { get; init; }
  [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
  public string Type { get; init; }

  /// <summary>
  /// </summary>
  public Msg() : base() { }
  /// <summary>
  /// </summary>
  /// <param name="body">
  /// </param>
  /// <param name="fromId">
  /// </param>
  /// <param name="id">
  /// </param>
  /// <param name="toIds">
  /// </param>
  /// <param name="type">
  /// </param>
  public Msg([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] string body, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] string fromId, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] string id, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] string[] toIds, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] string type) => (Body, FromId, ID, ToIds, Type) = (body, fromId, id, toIds, type);
  public Msg([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] Msg original) => (Body, FromId, ID, ToIds, Type) = (original.Body, original.FromId, original.ID, original.ToIds, original.Type);
  public void Deconstruct([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out string body, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out string fromId, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out string id, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out string[] toIds, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out string type) => (body, fromId, id, toIds, type) = (Body, FromId, ID, ToIds, Type);

  /// <summary>Calculates the maximum number of bytes produced by encoding the current record.</summary>
  [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
  private protected int GetMaxByteCount() {
    int byteCount = 0;
    byteCount += sizeof(uint) + global::System.Text.Encoding.UTF8.GetMaxByteCount(Body.Length);
    byteCount += sizeof(uint) + global::System.Text.Encoding.UTF8.GetMaxByteCount(FromId.Length);
    byteCount += sizeof(uint) + global::System.Text.Encoding.UTF8.GetMaxByteCount(ID.Length);
    {
      var length0 = unchecked((uint)ToIds.Length);
      byteCount += sizeof(uint);
      for (var i0 = 0; i0 < length0; i0++) {
        byteCount += sizeof(uint) + global::System.Text.Encoding.UTF8.GetMaxByteCount(ToIds[i0].Length);
      }
    }
    byteCount += sizeof(uint) + global::System.Text.Encoding.UTF8.GetMaxByteCount(Type.Length);
    return byteCount;
  }


  /// <summary>Calculates the number of bytes produced by encoding the current record.</summary>
  [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
  private protected int GetByteCount() {
    int byteCount = 0;
    byteCount += sizeof(uint) + global::System.Text.Encoding.UTF8.GetByteCount(Body);
    byteCount += sizeof(uint) + global::System.Text.Encoding.UTF8.GetByteCount(FromId);
    byteCount += sizeof(uint) + global::System.Text.Encoding.UTF8.GetByteCount(ID);
    {
      var length0 = unchecked((uint)ToIds.Length);
      byteCount += sizeof(uint);
      for (var i0 = 0; i0 < length0; i0++) {
        byteCount += sizeof(uint) + global::System.Text.Encoding.UTF8.GetByteCount(ToIds[i0]);
      }
    }
    byteCount += sizeof(uint) + global::System.Text.Encoding.UTF8.GetByteCount(Type);
    return byteCount;
  }

  [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
  public sealed override byte[] Encode() {
    var writer = global::Bebop.Runtime.BebopWriter.Create();
    __EncodeInto(this, ref writer);
    return writer.ToArray();
  }
  [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
  public static byte[] Encode(Msg record) {
    var writer = global::Bebop.Runtime.BebopWriter.Create();
    __EncodeInto(record, ref writer);
    return writer.ToArray();
  }

  [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
  public sealed override byte[] Encode(int initialCapacity) {
    var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
    __EncodeInto(this, ref writer);
    return writer.ToArray();
  }
  [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
  public static byte[] Encode(Msg record, int initialCapacity) {
    var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
    __EncodeInto(record, ref writer);
    return writer.ToArray();
  }

  [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
  public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably() {
    var writer = global::Bebop.Runtime.BebopWriter.Create();
    __EncodeInto(this, ref writer);
    return writer.ToImmutableArray();
  }
  [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
  public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(Msg record) {
    var writer = global::Bebop.Runtime.BebopWriter.Create();
    __EncodeInto(record, ref writer);
    return writer.ToImmutableArray();
  }

  [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
  public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(int initialCapacity) {
    var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
    __EncodeInto(this, ref writer);
    return writer.ToImmutableArray();
  }
  [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
  public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(Msg record, int initialCapacity) {
    var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
    __EncodeInto(record, ref writer);
    return writer.ToImmutableArray();
  }

  [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
  public sealed override int EncodeIntoBuffer(byte[] outBuffer) {
    var writer = global::Bebop.Runtime.BebopWriter.Create(outBuffer);
    return __EncodeInto(this, ref writer);
  }
  [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
  public static int EncodeIntoBuffer(Msg record, byte[] outBuffer) {
    var writer = global::Bebop.Runtime.BebopWriter.Create(outBuffer);
    return __EncodeInto(record, ref writer);
  }

  #region Static Decode Methods
  [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
  public static Msg Decode(byte[] record) {
    var reader = global::Bebop.Runtime.BebopReader.From(record);
    return __DecodeFrom(ref reader);
  }

  [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
  public static Msg Decode(global::System.ReadOnlySpan<byte> record) {
    var reader = global::Bebop.Runtime.BebopReader.From(record);
    return __DecodeFrom(ref reader);
  }

  [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
  public static Msg Decode(global::System.ReadOnlyMemory<byte> record) {
    var reader = global::Bebop.Runtime.BebopReader.From(record);
    return __DecodeFrom(ref reader);
  }

  [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
  public static Msg Decode(global::System.ArraySegment<byte> record) {
    var reader = global::Bebop.Runtime.BebopReader.From(record);
    return __DecodeFrom(ref reader);
  }

  [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
  public static Msg Decode(global::System.Collections.Immutable.ImmutableArray<byte> record) {
    var reader = global::Bebop.Runtime.BebopReader.From(record);
    return __DecodeFrom(ref reader);
  }

  #endregion
  #region Internal Use
  /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
  [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
  internal static int __EncodeInto(Msg record, ref global::Bebop.Runtime.BebopWriter writer) {
    var before = writer.Length;
    writer.WriteString(record.Body);
    writer.WriteString(record.FromId);
    writer.WriteString(record.ID);
    {
      var length0 = unchecked((uint)record.ToIds.Length);
      writer.WriteUInt32(length0);
      for (var i0 = 0; i0 < length0; i0++) {
        writer.WriteString(record.ToIds[i0]);
      }
    }
    writer.WriteString(record.Type);
    var after = writer.Length;
    return after - before;
  }


  /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
  [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
  internal static Msg __DecodeFrom(ref global::Bebop.Runtime.BebopReader reader) {

    string field0;
    field0 = reader.ReadString();
    string field1;
    field1 = reader.ReadString();
    string field2;
    field2 = reader.ReadString();
    string[] field3;
    {
      var length0 = unchecked((int)reader.ReadUInt32());
      field3 = new string[length0];
      for (var i0 = 0; i0 < length0; i0++) {
        string x0;
        x0 = reader.ReadString();
        field3[i0] = x0;
      }
    }
    string field4;
    field4 = reader.ReadString();
    return new Msg {
      Body = field0,
      FromId = field1,
      ID = field2,
      ToIds = field3,
      Type = field4,
    };
  }

  #endregion
  #region Equality
  public bool Equals(Msg other) {
    if (ReferenceEquals(null, other)) {
      return false;
    }
    if (ReferenceEquals(this, other)) {
      return true;
    }
    return Body == other.Body && FromId == other.FromId && ID == other.ID && (ToIds is null ? other.ToIds is null : other.ToIds is not null && global::System.Linq.Enumerable.SequenceEqual(ToIds, other.ToIds)) && Type == other.Type;
  }

  public override bool Equals(object obj) {
    if (ReferenceEquals(null, obj)) {
      return false;
    }
    if (ReferenceEquals(this, obj)) {
      return true;
    }
    if (obj is not Msg baseType) {
      return false;
    }
    return Equals(baseType);
  }

  public override int GetHashCode() {
    int hash = 1;
    hash ^= Body.GetHashCode();
    hash ^= FromId.GetHashCode();
    hash ^= ID.GetHashCode();
    hash ^= ToIds.GetHashCode();
    hash ^= Type.GetHashCode();
    return hash;
  }

  public static bool operator ==(Msg left, Msg right) => Equals(left, right);
  public static bool operator !=(Msg left, Msg  right) => !Equals(left, right);
  #endregion

}

