//
// This code was generated by a tool.
//
//
//   bebopc version:
//       3.2.0
//
//
//   bebopc source:
//       https://github.com/6over3/bebop
//
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
//

#![allow(warnings)]

use ::std::io::Write as _;
use ::core::convert::TryInto as _;
use ::bebop::FixedSized as _;

#[derive(Clone, Debug, PartialEq)]
pub struct Msg<'raw> {
    pub body: &'raw str,
    pub from_id: &'raw str,
    pub id: &'raw str,
    pub to_ids: ::std::vec::Vec<&'raw str>,
    pub _type: &'raw str,
}

impl<'raw> ::bebop::SubRecord<'raw> for Msg<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <&'raw str>::MIN_SERIALIZED_SIZE +
        <&'raw str>::MIN_SERIALIZED_SIZE +
        <&'raw str>::MIN_SERIALIZED_SIZE +
        <::std::vec::Vec<&'raw str>>::MIN_SERIALIZED_SIZE +
        <&'raw str>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.body.serialized_size() +
        self.from_id.serialized_size() +
        self.id.serialized_size() +
        self.to_ids.serialized_size() +
        self._type.serialized_size()
    }

    ::bebop::define_serialize_chained!(Self => |zelf, dest| {
        Ok(
            zelf.body._serialize_chained(dest)? +
            zelf.from_id._serialize_chained(dest)? +
            zelf.id._serialize_chained(dest)? +
            zelf.to_ids._serialize_chained(dest)? +
            zelf._type._serialize_chained(dest)?
        )
    });

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v3) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v4) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            body: v0,
            from_id: v1,
            id: v2,
            to_ids: v3,
            _type: v4,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for Msg<'raw> {}

#[cfg(feature = "bebop-owned-all")]
pub mod owned {
    #![allow(warnings)]

    use ::std::io::Write as _;
    use ::core::convert::TryInto as _;
    use ::bebop::FixedSized as _;

    #[derive(Clone, Debug, PartialEq)]
    pub struct Msg {
        pub body: String,
        pub from_id: String,
        pub id: String,
        pub to_ids: ::std::vec::Vec<String>,
        pub _type: String,
    }

    impl<'raw> ::core::convert::From<super::Msg<'raw>> for Msg {
        fn from(value: super::Msg) -> Self {
            Self {
                body: value.body.into(),
                from_id: value.from_id.into(),
                id: value.id.into(),
                to_ids: value.to_ids.into_iter().map(|value| value.into()).collect(),
                _type: value._type.into(),
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for Msg {
        const MIN_SERIALIZED_SIZE: usize =
            <String>::MIN_SERIALIZED_SIZE +
            <String>::MIN_SERIALIZED_SIZE +
            <String>::MIN_SERIALIZED_SIZE +
            <::std::vec::Vec<String>>::MIN_SERIALIZED_SIZE +
            <String>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.body.serialized_size() +
            self.from_id.serialized_size() +
            self.id.serialized_size() +
            self.to_ids.serialized_size() +
            self._type.serialized_size()
        }

        ::bebop::define_serialize_chained!(Self => |zelf, dest| {
            Ok(
                zelf.body._serialize_chained(dest)? +
                zelf.from_id._serialize_chained(dest)? +
                zelf.id._serialize_chained(dest)? +
                zelf.to_ids._serialize_chained(dest)? +
                zelf._type._serialize_chained(dest)?
            )
        });

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v3) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v4) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((i, Self {
                body: v0,
                from_id: v1,
                id: v2,
                to_ids: v3,
                _type: v4,
            }))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for Msg {}}
