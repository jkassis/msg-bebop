//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           3.2.0
//
//
//       bebopc source:
//           https://github.com/6over3/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
import { BebopView, BebopRuntimeError, BebopRecord } from "bebop";

export const BEBOP_SCHEMA = new Uint8Array ([
3, 1, 0, 0, 0, 77, 115, 103, 0, 1, 0, 0, 20, 0, 0, 0, 0,
5, 98, 111, 100, 121, 0, 245, 255, 255, 255, 0, 102, 114,
111, 109, 73, 100, 0, 245, 255, 255, 255, 0, 105, 100, 0,
245, 255, 255, 255, 0, 116, 111, 73, 100, 115, 0, 242,
255, 255, 255, 0, 245, 255, 255, 255, 0, 116, 121, 112,
101, 0, 245, 255, 255, 255, 0, 0, 0, 0, 0
]);

export interface Msg {

  readonly body: string;

  readonly fromId: string;

  readonly id: string;

  readonly toIds: string[];

  readonly type: string;
}

export const Msg = /*#__PURE__*/ Object.freeze(/*#__PURE__*/ Object.assign(
  // Factory function
  (data: Msg): Msg & BebopRecord => {
    return Object.freeze({
      ...data,
      encode(): Uint8Array {
        return Msg.encode(this);
      }
    });
  },
  // Static methods
  {
    encode(record: Msg): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      Msg.encodeInto(record, view);
      return view.toArray();
    },

    encodeInto(record: Msg, view: BebopView): void {
      view.writeString(record.body);
      view.writeString(record.fromId);
      view.writeString(record.id);
      {
        const length0 = record.toIds.length;
        view.writeUint32(length0);
        for (let i0 = 0; i0 < length0; i0++) {
          view.writeString(record.toIds[i0]);
        }
      }
      view.writeString(record.type);
    },

    decode(buffer: Uint8Array): Msg & BebopRecord {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      const decoded = Msg.readFrom(view);
      return Msg(decoded);
    },

    readFrom(view: BebopView): Msg {
      let field0: string;
      field0 = view.readString();
      let field1: string;
      field1 = view.readString();
      let field2: string;
      field2 = view.readString();
      let field3: string[];
      {
        const length0 = view.readUint32();
        field3 = [];
        for (let i0 = 0; i0 < length0; i0++) {
          let x0: string;
          x0 = view.readString();
          field3[i0] = x0;
        }
      }
      let field4: string;
      field4 = view.readString();
      return {
        body: field0,
        fromId: field1,
        id: field2,
        toIds: field3,
        type: field4,
      };
    },
  }
));

